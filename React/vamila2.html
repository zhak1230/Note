<!DOCTYPE html>
<html lang="en">
  <head> </head>
  <body>
    <div id="root"></div>
  </body>
  <script src="https://unpkg.com/react@17/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script type="text/babel">
    function Btn({ text, onClick }) {
      console.log(text, 'was resdered');
      return (
        <button
          onClick={onClick}
          style={{
            backgroundColor: 'tomato',
            color: 'white',
            margin: '10px',
            padding: '10px 20px',
            border: 0,
            borderRadius: 10,
          }}
        >
          {text}
        </button>
      );
    }
    const MemorizedBtn = React.memo(Btn);
    // 변경 사항이 있는 버튼만 리랜더 시킴(속도 업)
    function App() {
      const [value, setValue] = React.useState('Save Changes');
      const changeValue = () => setValue('Revert Changes');
      return (
        <div>
          <MemorizedBtn text={value} onClick={changeValue} />
          <MemorizedBtn text='Continue' />
        </div>
      );
    }
    const root = document.getElementById('root');
    ReactDOM.render(<App />, root);
  </script>
</html>

<!-- 
Btn onClick={changeValue} /> 이것은 이벤트 리스너를 붙인 것이 아닌, 컴포넌트에 onClick이라는 프롭을 전달한 것이다. 여기서 onClick은 단순히 props의 이름이다. (2:07)

결국 컴포넌트에 onClick 이벤트리스너를 붙이고 싶다면 해당 컴포넌트의 props으로 이벤트 리스너를 보내고, 그걸 받아오면 해당 컴포넌트의 최상단 엘리먼트에 onClick 이벤트 리스너를 붙이면 된다 (3:46)

즉, 컴포넌트에는 HTML Element처럼 속성을 지정해줄 수 없다.
컴포넌트에 그러한 행위를 하는것은 그저 props를 전달해 주는 것 뿐이다.

리액트의 렌더링방식 (6:18)

불필요한 리렌더링을 MEMO로 막기 (8:40)



1. props에 function도 보낼 수 있음
이것은 JSX로 html 태그 자체에 이벤트 리스너를 넣는것과는 전혀 다른 것임.
그저 이벤트를 실행시키는 함수가 프로퍼티로 들어간 것임.
prop은 그냥 부모에서 자식으로 데이터를 넘길 때 사용하는 argument의 역할이니까!

2. (07:41~) 부모의 상태를 바꾸는 함수를 만들었고, 부모 컴포넌트에서 그 함수를 prop으로 보내면 자식 컴포넌트에서 그 함수가 실행된다.

3. 불필요한 re-render는 React.memo()로 관리할 수 있음
부모 컴포넌트의 state를 변경하면 당연히 그 자식 컴포넌트들도 Re-render가 일어남. 불필요한 렌더링이 발생할 수도 있는데, 이 경우에는 React.memo()로 prop의 변경이 일어난 부분만 렌더링 시킬 수 있음. 아주 많은 자식 컴포넌트를 가지고 있는 부모 컴포넌트일 때 사용하면 될듯.

* React.memo()
컴포넌트가 React.memo()로 wrapping 될 때, React는 컴포넌트를 렌더링하고 결과를 메모이징(Memoizing)한다. 그리고 다음 렌더링이 일어날 때 props가 같다면, React는 메모이징(Memoizing)된 내용을 재사용한다.
 -->
